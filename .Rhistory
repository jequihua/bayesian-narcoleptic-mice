colnames(wl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="w"){
contador=contador+1
wl_matrix[contador,1]=rownames(adjmatrix)[i]
wl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
whitelist = wl_matrix,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
# Load modified adjacency matrix.
adjmatrixm = read.csv("D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/20190814_adj2.csv",
header=TRUE,
stringsAsFactors = FALSE,
row.names=1)
# remove w's with both directions
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
if(adjmatrixm[i,j]=="w"&adjmatrixm[j,i]=="w"){
adjmatrixm[j,i]="0"
}
if(adjmatrixm[i,j]=="1"&adjmatrixm[j,i]=="1"){
adjmatrixm[j,i]="0"
}
}
}
###### Initialize empty graph from adjacency matrix.
# Initialize empty graph with appropriate node names
# the names are read from the row names of a adjacency matrix
# read from a file (e.g. a csv) or a specified vector
initAdj = function(adj_mat, custom_names=NULL){
if (is.null(custom_names)){
bngraph = empty.graph(row.names(adj_mat))
}
else{
bngraph = empty.graph(custom_names)
}
return(bngraph)
}
initialized_graph = initAdj(adjmatrixm)
### Initial BN.
start_adj = (adjmatrixm=="1")*1
# For a group of nodes set arcs based on a adjacency matrix
setArcs = function(bngraph,
adj_mat){
amat(bngraph) = as.matrix(adj_mat,row.names=TRUE)
return(bngraph)
}
start_graph = setArcs(initialized_graph,start_adj)
### Black listed arcs.
nbl = sum(adjmatrixm=="0")
bl_matrix = matrix(0,nbl,2)
colnames(bl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="0"){
contador=contador+1
bl_matrix[contador,1]=rownames(adjmatrix)[i]
bl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### White listed arcs.
nbl = sum(adjmatrixm=="w")
wl_matrix = matrix(0,nbl,2)
colnames(wl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="w"){
contador=contador+1
wl_matrix[contador,1]=rownames(adjmatrix)[i]
wl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
whitelist = wl_matrix,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
# Load modified adjacency matrix.
adjmatrixm = read.csv("D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/20190814_adj2.csv",
header=TRUE,
stringsAsFactors = FALSE,
row.names=1)
# remove w's with both directions
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
if(adjmatrixm[i,j]=="w"&adjmatrixm[j,i]=="w"){
adjmatrixm[j,i]="0"
}
if(adjmatrixm[i,j]=="1"&adjmatrixm[j,i]=="1"){
adjmatrixm[j,i]="0"
}
}
}
###### Initialize empty graph from adjacency matrix.
# Initialize empty graph with appropriate node names
# the names are read from the row names of a adjacency matrix
# read from a file (e.g. a csv) or a specified vector
initAdj = function(adj_mat, custom_names=NULL){
if (is.null(custom_names)){
bngraph = empty.graph(row.names(adj_mat))
}
else{
bngraph = empty.graph(custom_names)
}
return(bngraph)
}
initialized_graph = initAdj(adjmatrixm)
### Initial BN.
start_adj = (adjmatrixm=="1")*1
# For a group of nodes set arcs based on a adjacency matrix
setArcs = function(bngraph,
adj_mat){
amat(bngraph) = as.matrix(adj_mat,row.names=TRUE)
return(bngraph)
}
start_graph = setArcs(initialized_graph,start_adj)
### Black listed arcs.
nbl = sum(adjmatrixm=="0")
bl_matrix = matrix(0,nbl,2)
colnames(bl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="0"){
contador=contador+1
bl_matrix[contador,1]=rownames(adjmatrix)[i]
bl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### White listed arcs.
nbl = sum(adjmatrixm=="w")
wl_matrix = matrix(0,nbl,2)
colnames(wl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="w"){
contador=contador+1
wl_matrix[contador,1]=rownames(adjmatrix)[i]
wl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
whitelist = wl_matrix,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
# Load modified adjacency matrix.
adjmatrixm = read.csv("D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/20190814_adj2.csv",
header=TRUE,
stringsAsFactors = FALSE,
row.names=1)
# remove w's with both directions
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
if(adjmatrixm[i,j]=="w"&adjmatrixm[j,i]=="w"){
adjmatrixm[j,i]="0"
}
if(adjmatrixm[i,j]=="1"&adjmatrixm[j,i]=="1"){
adjmatrixm[j,i]="0"
}
}
}
###### Initialize empty graph from adjacency matrix.
# Initialize empty graph with appropriate node names
# the names are read from the row names of a adjacency matrix
# read from a file (e.g. a csv) or a specified vector
initAdj = function(adj_mat, custom_names=NULL){
if (is.null(custom_names)){
bngraph = empty.graph(row.names(adj_mat))
}
else{
bngraph = empty.graph(custom_names)
}
return(bngraph)
}
initialized_graph = initAdj(adjmatrixm)
### Initial BN.
start_adj = (adjmatrixm=="1")*1
# For a group of nodes set arcs based on a adjacency matrix
setArcs = function(bngraph,
adj_mat){
amat(bngraph) = as.matrix(adj_mat,row.names=TRUE)
return(bngraph)
}
start_graph = setArcs(initialized_graph,start_adj)
### Black listed arcs.
nbl = sum(adjmatrixm=="0")
bl_matrix = matrix(0,nbl,2)
colnames(bl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="0"){
contador=contador+1
bl_matrix[contador,1]=rownames(adjmatrix)[i]
bl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### White listed arcs.
nbl = sum(adjmatrixm=="w")
wl_matrix = matrix(0,nbl,2)
colnames(wl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="w"){
contador=contador+1
wl_matrix[contador,1]=rownames(adjmatrix)[i]
wl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
whitelist = wl_matrix,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
# Load modified adjacency matrix.
adjmatrixm = read.csv("D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/20190814_adj2.csv",
header=TRUE,
stringsAsFactors = FALSE,
row.names=1)
# remove w's with both directions
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
if(adjmatrixm[i,j]=="w"&adjmatrixm[j,i]=="w"){
adjmatrixm[j,i]="0"
}
if(adjmatrixm[i,j]=="1"&adjmatrixm[j,i]=="1"){
adjmatrixm[j,i]="0"
}
}
}
###### Initialize empty graph from adjacency matrix.
# Initialize empty graph with appropriate node names
# the names are read from the row names of a adjacency matrix
# read from a file (e.g. a csv) or a specified vector
initAdj = function(adj_mat, custom_names=NULL){
if (is.null(custom_names)){
bngraph = empty.graph(row.names(adj_mat))
}
else{
bngraph = empty.graph(custom_names)
}
return(bngraph)
}
initialized_graph = initAdj(adjmatrixm)
### Initial BN.
start_adj = (adjmatrixm=="1")*1
# For a group of nodes set arcs based on a adjacency matrix
setArcs = function(bngraph,
adj_mat){
amat(bngraph) = as.matrix(adj_mat,row.names=TRUE)
return(bngraph)
}
start_graph = setArcs(initialized_graph,start_adj)
### Black listed arcs.
nbl = sum(adjmatrixm=="0")
bl_matrix = matrix(0,nbl,2)
colnames(bl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="0"){
contador=contador+1
bl_matrix[contador,1]=rownames(adjmatrix)[i]
bl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### White listed arcs.
nbl = sum(adjmatrixm=="w")
wl_matrix = matrix(0,nbl,2)
colnames(wl_matrix)=c("from","to")
contador=0
for (j in 1:ncol(adjmatrixm)){
for (i in 1:nrow(adjmatrixm)){
cellv = adjmatrixm[i,j]
if(cellv=="w"){
contador=contador+1
wl_matrix[contador,1]=rownames(adjmatrix)[i]
wl_matrix[contador,2]=colnames(adjmatrix)[j]
}
}
}
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
whitelist = wl_matrix,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
### Learn structure of BN based on previous definitions.
learnt_bn_structure = hc(brikdf_disc_clean,
start=start_graph,
blacklist = bl_matrix,
score='k2',
debug=TRUE)
plot(learnt_bn_structure)
# fit network
net <- bn.fit(learnt_bn_structure,
data=brikdf_disc,
method='bayes')
# fit network
net <- bn.fit(learnt_bn_structure,
data=brikdf_disc[,c(3:18,20:23)],
method='bayes')
# We use the junction tree algorithm to create
# an independence network that we can query
prior <- compile(as.grain(net))
library("gRain")
# We use the junction tree algorithm to create
# an independence network that we can query
prior <- compile(as.grain(net))
net$X1_map_rb_2013_12
net
?cpquery
names(brikdf_disc[,c(3:18,20:23)])
cpquery(net,"X1_map_rb_2013_12","Panthera_onca")
levels(brikdf_disc_clean$X1_map_rb_2013_12)
levels(brikdf_disc_clean$Panthera_onca)
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="0")
levels(brikdf_disc_clean$AlturaTotal_media)
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="0"&Puma_concolor=="0",)
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1"&Puma_concolor=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1"&Puma_concolor=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="0"&Puma_concolor=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1"&Puma_concolor=="0")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1"&Puma_concolor=="0")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Puma_concolor=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="1"&Puma_concolor=="0")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Panthera_onca=="0"&Puma_concolor=="0")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Bos_taurus=="0"&Canis_lupus_familiaris=="0")
cpquery(net,X1_map_rb_2013_12=="(0.834,0.974]",Bos_taurus=="1"&Canis_lupus_familiaris=="1")
names(brikdf_disc)
prediction = predict(prior,
response="X1_map_rb_2013_12",
newdata=brikdf_disc[1,],
type="distribution")
prediction
prediction$pred
prediction1 = predict(prior,
response="X1_map_rb_2013_12",
newdata=brikdf_disc[1,],
type="distribution")
prediction2 = predict(prior,
response="X1_map_rb_2013_12",
newdata=brikdf_disc[1,],
type="distribution")
rbind(prediction1$pred,prediction2$pred)
bind(prediction1$pred,prediction2$pred)
cbind(prediction1$pred,prediction2$pred)
cbind(unlist(prediction1$pred),(prediction2$pred))
rbind(unlist(prediction1$pred),(prediction2$pred))
cbind(unlist(prediction1$pred),(prediction2$pred))
cbind(unlist(prediction1$pred$X1_map_rb_2013_12),(prediction2$pred$X1_map_rb_2013_12))
crbind(unlist(prediction1$pred$X1_map_rb_2013_12),(prediction2$pred$X1_map_rb_2013_12))
rbind(unlist(prediction1$pred$X1_map_rb_2013_12),(prediction2$pred$X1_map_rb_2013_12))
w = rbind(unlist(prediction1$pred$X1_map_rb_2013_12),(prediction2$pred$X1_map_rb_2013_12))
class(w)
a = brikdf_disc[,c(3:18,20:23)]
# Prediction
nworker=15
cl <- parallel::makeCluster(nworker)
cl <- parallel::makeCluster(nworker)
doParallel::registerDoParallel(cl)
# Start the clock!
ptm <- proc.time()
prediction = foreach(suba=isplitRows(a, chunkSize=nworker),.combine = rbind, .packages=c("bnlearn","gRain","itertools")) %dopar% {
predict(prior,
response="X1_map_rb_2013_12",
newdata=suba,
type="distribution")$pred$X1_map_rb_2013_12
}
#library("tidyverse")
library("itertools")
library("foreach")
library("doParallel")
# Prediction
nworker=15
cl <- parallel::makeCluster(nworker)
doParallel::registerDoParallel(cl)
# Start the clock!
ptm <- proc.time()
prediction = foreach(suba=isplitRows(a, chunkSize=nworker),.combine = rbind, .packages=c("bnlearn","gRain","itertools")) %dopar% {
predict(prior,
response="X1_map_rb_2013_12",
newdata=suba,
type="distribution")$pred$X1_map_rb_2013_12
}
# Stop the clock
proc.time() - ptm
stopCluster(cl)
saveRDS(preciction,"D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/ie_20180814_prediction.csv")
saveRDS(preciction,"D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/ie_20180814_prediction.rds")
saveRDS(prediction,"D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/ie_20180814_prediction.rds")
warnings()
head(prediction)
saveRDS(prediction,"D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/ie_20180814_prediction.rds")
gc()
prediction_ie = prediction[,1]*1+prediction[,2]*2+prediction[,3]*3+prediction[,4]*4+prediction[,5]*5+prediction[,6]*6+prediction[,7]*7
prediction_ie
prediction_ie = (prediction_ie-min(prediction_ie))/(max(prediction_ie)-min(prediction_ie))
max(prediction_ie)
min(prediction_ie)
final_raster = data.frame(prediction_ie,x=brikdf_disc$x,y=brikdf_disc$y)
coordinates(final_raster)=~x+y
gridded(final_raster)=TRUE
final_raster = raster(final_raster)
projection(final_raster)=projection(pixelid)
# save raster
rf <- writeRaster(final_raster, filename="D:/repositories/EcosystemIntegrity-I/data/20190815_ie.tif",
format="GTiff", overwrite=TRUE)
names(a)
# save raster
rf <- writeRaster(final_raster, filename="D:/repositories/EcosystemIntegrity-I/data/20190815_ie.tif",
format="GTiff", overwrite=TRUE)
remove(prediction)
gc()
nworker=15
cl <- parallel::makeCluster(nworker)
doParallel::registerDoParallel(cl)
# Start the clock!
ptm <- proc.time()
prediction = foreach(suba=isplitRows(a, chunkSize=nworker),.combine = rbind, .packages=c("bnlearn","gRain","itertools")) %dopar% {
predict(prior,
response="Panthera_onca",
newdata=suba,
type="distribution")$pred$Panthera_onca
}
# Stop the clock
proc.time() - ptm
stopCluster(cl)
saveRDS(prediction,"D:/repositories/EcosystemIntegrity-I/data/adjacency_matrix/Panthera_onca_20180814_prediction.rds")
gc()
head(prediction)
final_raster = data.frame(prediction[,1],x=brikdf_disc$x,y=brikdf_disc$y)
coordinates(final_raster)=~x+y
gridded(final_raster)=TRUE
final_raster = raster(final_raster)
projection(final_raster)=projection(pixelid)
# save raster
rf <- writeRaster(final_raster, filename="D:/repositories/EcosystemIntegrity-I/data/final_rasters/20190815_Panthera_onca.tif",
format="GTiff", overwrite=TRUE)
# save raster
rf <- writeRaster(final_raster, filename="D:/repositories/EcosystemIntegrity-I/data/output_rasters/20190815_Panthera_onca.tif",
format="GTiff", overwrite=TRUE)
final_raster = data.frame(prediction[,2],x=brikdf_disc$x,y=brikdf_disc$y)
coordinates(final_raster)=~x+y
gridded(final_raster)=TRUE
final_raster = raster(final_raster)
projection(final_raster)=projection(pixelid)
# save raster
rf <- writeRaster(final_raster, filename="D:/repositories/EcosystemIntegrity-I/data/output_rasters/20190815_Panthera_onca.tif",
format="GTiff", overwrite=TRUE)
setwd("D:/repositories/bayesian-narcoleptic-mice/")
# Load packages.
library("tidyverse")
library("ggplot2")
library("brms")
library("brmstools")
library("bayesplot")
# Load misc. functions.
source("./R/misc_functions.R")
# Load recorded behaviors data.
data <- read_csv("./data/videos/recorded_behaviors.csv")
### Duration of each BA (narcoleptic attack) model.
ba_seconds <- filter(data,behavior=="BA")
# Change variable types.
ba_seconds$group <- as.factor(ba_seconds$group)
ba_seconds$mouse <- as.factor(ba_seconds$mouse)
# Which priors can we specify for our model?
get_prior(seconds ~ group + (1|mouse), data=ba_seconds)
# Fit brms model for duration of each BA attack.
ba_seconds_fit <- brm(seconds ~ group + (1|mouse),
data = ba_seconds,
family = lognormal(),
control = list(adapt_delta = 0.999))
summary(ba_seconds_fit)
